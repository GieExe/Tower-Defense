<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Tower Defense V3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            overflow: hidden;
        }
        canvas {
            background-color: #333;
            display: block;
            border: 4px solid #555;
            border-radius: 8px;
            margin: 0 auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            cursor: pointer;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 20px;
        }
        .controls, .stats {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #555;
            margin-bottom: 20px;
            width: 100%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            font-size: 0.9em;
            text-align: left;
        }
        .controls button, .tower-button {
            font-family: 'Press Start 2P', cursive;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.3s;
            margin: 5px;
            border-bottom: 3px solid #555; /* Default shadow */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            vertical-align: middle;
            font-size: 0.8em; /* Slightly smaller button text */
        }
        .controls button:hover, .tower-button:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-1px); /* Slight lift on hover */
        }
        .controls button:active, .tower-button:active {
            transform: translateY(1px); /* Adjusted press effect */
            border-bottom-width: 1px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Specific button colors */
        #startWaveBtn { background-color: #28a745; border-bottom-color: #1e7e34; }
        #startWaveBtn:hover { background-color: #218838; }
        #sellTowerBtn { background-color: #dc3545; border-bottom-color: #a71d2a; }
        #sellTowerBtn:hover { background-color: #c82333; }
        #upgradeTowerBtn { background-color: #ffc107; border-bottom-color: #ba8b00; color: #333;} /* Yellow for upgrade */
        #upgradeTowerBtn:hover { background-color: #e0a800; }

        /* Tower Purchase Buttons */
        #basicTowerBtn { background-color: #17a2b8; border-bottom-color: #117a8b; } /* Cyan */
        #basicTowerBtn:hover { background-color: #138496; }
        #laserTowerBtn { background-color: #fd7e14; border-bottom-color: #c75e0a; } /* Orange for Laser */
        #laserTowerBtn:hover { background-color: #e66e0c; }
        #slowTowerBtn { background-color: #6495ED; border-bottom-color: #4169E1; } /* Cornflower Blue for Slow */
        #slowTowerBtn:hover { background-color: #4682B4; } /* Steel Blue */


        .tower-button.selected {
            box-shadow: 0 0 10px 3px #0ff; /* Neon cyan glow when selected for purchase */
            transform: scale(1.05);
        }
        .tower-button.disabled, #sellTowerBtn.disabled, #startWaveBtn.disabled, #upgradeTowerBtn.disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            border-bottom-color: #545b62;
            box-shadow: none;
            transform: none;
            color: #ccc; /* Lighter text for disabled */
        }
        #sellTowerBtn, #upgradeTowerBtn { display: none; } /* Hide action buttons initially */
        #sellTowerBtn:not(.disabled), #upgradeTowerBtn:not(.disabled) { display: inline-block; } /* Show when active */

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 30px 40px;
            border-radius: 10px;
            font-size: 1.5em;
            text-align: center;
            z-index: 100;
            border: 3px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            display: none; /* Hidden by default */
        }
        .message-box button {
             font-family: 'Press Start 2P', cursive;
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 20px;
            border-bottom: 3px solid #0056b3;
        }
         .message-box button:hover {
            background-color: #0056b3;
         }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl mb-4 text-cyan-300 text-center">Pixel Tower Defense V3</h1>

        <div class="stats" id="stats">
            <span>Money: <span id="money">120</span></span>
            <span>Score: <span id="score">0</span></span>
            <span>Lives: <span id="lives">10</span></span>
            <span>Wave: <span id="wave">0</span></span>
        </div>

        <div class="controls text-center">
            <button id="basicTowerBtn" class="tower-button" data-type="basic">Basic</button>
            <button id="laserTowerBtn" class="tower-button" data-type="laser">Laser</button>
            <button id="slowTowerBtn" class="tower-button" data-type="slow">Slow</button>
            <br> <button id="startWaveBtn">Start Next Wave</button>
            <button id="upgradeTowerBtn" class="disabled">Upgrade</button>
            <button id="sellTowerBtn" class="disabled">Sell</button>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button id="messageBtn">OK</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- Game Configuration ---
            const TILE_SIZE = 40;
            const GRID_WIDTH = canvas.width / TILE_SIZE;
            const GRID_HEIGHT = canvas.height / TILE_SIZE;
            const STARTING_MONEY = 120; // Increased starting money
            const STARTING_LIVES = 10;
            const WAVE_START_DELAY = 300;
            const ENEMY_SPAWN_INTERVAL = 60;
            const SELL_PERCENTAGE = 0.7;

            // Enemy Config
            const ENEMY_START_HEALTH = 30; // Further reduced health
            const ENEMY_SPEED = 1;
            const ENEMY_HEALTH_INCREMENT = 15;

            // --- Tower Configuration ---
            // Structure: cost, range, damage, fireRate, color, shape, slowFactor, slowDuration
            // upgradeCosts: array of costs for each level upgrade (level 1->2, 2->3, ...)
            // upgradeStats: array of objects containing stats for each level (level 2, level 3, ...)
            const TOWER_TYPES = {
                'basic': {
                    cost: 50, range: 100, damage: 12, fireRate: 50, color: '#17a2b8', shape: 'rect', maxLevel: 2,
                    upgradeCosts: [75], // Cost Lvl 1 -> 2
                    upgradeStats: [{ damage: 18, range: 110 }] // Stats at Lvl 2
                },
                'laser': {
                    cost: 75, range: 90, damage: 7, fireRate: 25, color: '#fd7e14', shape: 'triangle', maxLevel: 2,
                    upgradeCosts: [100], // Cost Lvl 1 -> 2
                    upgradeStats: [{ damage: 10, fireRate: 20 }] // Stats at Lvl 2
                },
                'slow': {
                    cost: 60, range: 80, damage: 0, fireRate: 30, color: '#6495ED', shape: 'circle', maxLevel: 2,
                    slowFactor: 0.6, // Multiplies enemy speed (lower is slower)
                    slowDuration: 120, // Frames the slow lasts
                    upgradeCosts: [70], // Cost Lvl 1 -> 2
                    upgradeStats: [{ range: 95, slowFactor: 0.5 }] // Stats at Lvl 2
                }
            };

            // --- Game State ---
            let money = STARTING_MONEY;
            let score = 0;
            let lives = STARTING_LIVES;
            let wave = 0;
            let enemies = [];
            let towers = [];
            let projectiles = [];
            let grid = createGrid();
            let path = [];
            let placingTowerType = null;
            let selectedTower = null;
            let mouse = { x: 0, y: 0 };
            let waveInProgress = false;
            let enemiesToSpawn = 0;
            let spawnTimer = 0;
            let frameCount = 0;
            let gameOver = false;
            let gamePaused = false;

            // --- UI Elements ---
            const moneyDisplay = document.getElementById('money');
            const scoreDisplay = document.getElementById('score');
            const livesDisplay = document.getElementById('lives');
            const waveDisplay = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn');
            const sellTowerBtn = document.getElementById('sellTowerBtn');
            const upgradeTowerBtn = document.getElementById('upgradeTowerBtn');
            const towerButtons = document.querySelectorAll('.tower-button');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const messageBtn = document.getElementById('messageBtn');

            // --- Path Definition ---
            const pathPoints = [ { x: 0, y: 2 }, { x: 3, y: 2 }, { x: 3, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 4 }, { x: 14, y: 4 } ];
            calculatePixelPath();

            // --- Initialization ---
            updateUI(); // Initial UI setup
            setupEventListeners();

            // --- Game Loop ---
            function gameLoop() {
                if (gameOver || gamePaused) {
                     if (!gameOver) requestAnimationFrame(gameLoop);
                     return;
                }
                frameCount++;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                drawPath();
                handleWaves();
                handleEnemies(); // Includes applying slow effects
                handleTowers(); // Includes targeting and firing/applying effects
                handleProjectiles();
                drawTowers();
                drawEnemies();
                drawProjectiles();
                if (placingTowerType) {
                    drawTowerPlacementPreview();
                }
                requestAnimationFrame(gameLoop);
            }

            // --- Grid and Path --- (Largely unchanged)
            function createGrid() {
                const newGrid = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    newGrid[y] = [];
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        newGrid[y][x] = { type: 'empty', tower: null };
                    }
                }
                return newGrid;
            }
            function calculatePixelPath() { /* Unchanged */
                path = [];
                if (pathPoints.length === 0) return;
                path.push({ x: pathPoints[0].x * TILE_SIZE - TILE_SIZE, y: pathPoints[0].y * TILE_SIZE + TILE_SIZE / 2 });
                for (let i = 0; i < pathPoints.length; i++) {
                    const point = pathPoints[i];
                    const x = point.x * TILE_SIZE + TILE_SIZE / 2;
                    const y = point.y * TILE_SIZE + TILE_SIZE / 2;
                    path.push({ x, y });
                    if (i > 0) {
                        const prevPoint = pathPoints[i - 1];
                        if (point.x === prevPoint.x) {
                            const startY = Math.min(point.y, prevPoint.y);
                            const endY = Math.max(point.y, prevPoint.y);
                            for (let py = startY; py <= endY; py++) {
                                if (grid[py]?.[point.x]) grid[py][point.x].type = 'path';
                            }
                        } else {
                            const startX = Math.min(point.x, prevPoint.x);
                            const endX = Math.max(point.x, prevPoint.x);
                            for (let px = startX; px <= endX; px++) {
                                if (grid[point.y]?.[px]) grid[point.y][px].type = 'path';
                            }
                        }
                    } else {
                         if (grid[point.y]?.[point.x]) grid[point.y][point.x].type = 'path';
                    }
                }
                const lastGridPoint = pathPoints[pathPoints.length - 1];
                path.push({ x: (lastGridPoint.x + 1) * TILE_SIZE + TILE_SIZE, y: lastGridPoint.y * TILE_SIZE + TILE_SIZE / 2 });
            }
            function drawGrid() { /* Unchanged */
                ctx.strokeStyle = '#383838';
                ctx.lineWidth = 1;
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
            function drawPath() { /* Unchanged */
                ctx.strokeStyle = '#888';
                ctx.lineWidth = TILE_SIZE * 0.8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                if (path.length > 0) {
                    ctx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) {
                        ctx.lineTo(path[i].x, path[i].y);
                    }
                }
                ctx.stroke();
            }

             // --- Enemy Handling ---
            function spawnEnemy() {
                const health = ENEMY_START_HEALTH + (wave - 1) * ENEMY_HEALTH_INCREMENT;
                enemies.push({
                    x: path[0].x, y: path[0].y,
                    health: health, maxHealth: health,
                    speed: ENEMY_SPEED, pathIndex: 1,
                    size: TILE_SIZE * 0.4,
                    // Slow effect properties
                    speedMultiplier: 1, // 1 = normal speed, < 1 = slowed
                    slowTimer: 0 // Frames remaining for slow effect
                });
            }

            function handleEnemies() {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];

                    // Update slow effect timer
                    if (enemy.slowTimer > 0) {
                        enemy.slowTimer--;
                        if (enemy.slowTimer <= 0) {
                            enemy.speedMultiplier = 1; // Reset speed when timer runs out
                        }
                    }

                    // --- Movement ---
                    const effectiveSpeed = enemy.speed * enemy.speedMultiplier; // Use potentially slowed speed
                    if (enemy.pathIndex < path.length) {
                        const targetPoint = path[enemy.pathIndex];
                        const dx = targetPoint.x - enemy.x;
                        const dy = targetPoint.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < effectiveSpeed) {
                            enemy.x = targetPoint.x;
                            enemy.y = targetPoint.y;
                            enemy.pathIndex++;
                        } else {
                            enemy.x += (dx / distance) * effectiveSpeed;
                            enemy.y += (dy / distance) * effectiveSpeed;
                        }
                    } else { // Reached end
                        lives--;
                        updateUI();
                        enemies.splice(i, 1);
                        if (lives <= 0) endGame(false);
                        continue;
                    }
                    // Health Check
                    if (enemy.health <= 0) {
                        money += 5 + Math.floor(wave / 5); // Slightly increasing reward
                        score += 10;
                        updateUI();
                        enemies.splice(i, 1);
                    }
                }
            }

            function drawEnemies() {
                enemies.forEach(enemy => {
                    // Draw enemy body
                    ctx.fillStyle = '#28a745'; // Green enemy
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw border (blue if slowed, dark green otherwise)
                    ctx.strokeStyle = enemy.speedMultiplier < 1 ? '#007bff' : '#1e7e34'; // Blue border if slowed
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw health bar
                    const healthBarWidth = enemy.size * 2;
                    const healthBarHeight = 5;
                    const healthPercentage = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#555';
                    ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - healthBarHeight - 3, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = '#dc3545';
                    ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - healthBarHeight - 3, healthBarWidth * healthPercentage, healthBarHeight);
                });
            }

            // --- Tower Handling ---
             function canPlaceTower(gridX, gridY, towerType) {
                const config = TOWER_TYPES[towerType];
                if (!config) return false;
                if (!grid[gridY]?.[gridX]) return false; // Out of bounds check using optional chaining
                if (grid[gridY][gridX].type !== 'empty') return false;
                if (money < config.cost) return false;
                return true;
            }

            function placeTower(gridX, gridY) {
                 if (!placingTowerType) return;
                 const config = TOWER_TYPES[placingTowerType];
                 if (!config || !canPlaceTower(gridX, gridY, placingTowerType)) {
                     console.log("Cannot place tower here or not enough money.");
                     return;
                 }

                 money -= config.cost;
                 const towerX = gridX * TILE_SIZE + TILE_SIZE / 2;
                 const towerY = gridY * TILE_SIZE + TILE_SIZE / 2;
                 const newTower = {
                     x: towerX, y: towerY, gridX: gridX, gridY: gridY,
                     // Base stats from config
                     range: config.range, damage: config.damage, fireRate: config.fireRate,
                     slowFactor: config.slowFactor, slowDuration: config.slowDuration,
                     // Core properties
                     fireCooldown: 0, target: null, type: placingTowerType,
                     // Upgrade properties
                     level: 1, maxLevel: config.maxLevel, totalCost: config.cost // Track total investment
                 };
                 towers.push(newTower);
                 grid[gridY][gridX].type = 'tower';
                 grid[gridY][gridX].tower = newTower;

                 deselectTowerPurchase();
                 updateUI();
            }

            function handleTowers() {
                towers.forEach(tower => {
                    if (tower.fireCooldown > 0) {
                        tower.fireCooldown--;
                    }

                    // Retarget if needed (or if current target is out of range/dead)
                    if (!tower.target || tower.target.health <= 0 || getDistance(tower, tower.target) > tower.range) {
                        tower.target = findNearestEnemyInRange(tower);
                    }

                    // Fire projectile (for damage towers) or apply slow (for slow towers)
                    if (tower.fireCooldown <= 0 && tower.target) {
                        if (tower.type === 'slow') {
                            // Apply slow effect directly to enemies in range
                            applySlowEffect(tower); // Apply to all valid targets in range
                            tower.fireCooldown = tower.fireRate; // Reset cooldown after applying effect
                        } else if (tower.damage > 0) {
                            // Fire projectile for damage towers
                            fireProjectile(tower, tower.target);
                            tower.fireCooldown = tower.fireRate;
                        }
                    }
                });
            }

            // Apply slow effect from a specific tower to all valid enemies in its range
            function applySlowEffect(tower) {
                 enemies.forEach(enemy => {
                     if (getDistance(tower, enemy) <= tower.range) {
                         // Apply the slow - overwrite existing slow if this one is stronger or timer is longer?
                         // Simple approach: just reset timer and apply this tower's factor
                         enemy.speedMultiplier = tower.slowFactor;
                         enemy.slowTimer = tower.slowDuration;
                     }
                 });
            }


            function findNearestEnemyInRange(tower) { /* Unchanged */
                let nearestEnemy = null;
                let minDistanceSq = tower.range * tower.range;
                enemies.forEach(enemy => {
                    const dx = tower.x - enemy.x;
                    const dy = tower.y - enemy.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq <= minDistanceSq) {
                        minDistanceSq = distanceSq;
                        nearestEnemy = enemy;
                    }
                });
                return nearestEnemy;
            }

            function drawTowers() {
                towers.forEach(tower => {
                    const config = TOWER_TYPES[tower.type];
                    ctx.fillStyle = config.color;
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    // Draw shape
                    const towerSize = TILE_SIZE * 0.3 + (tower.level - 1) * 2; // Slightly bigger per level
                    if (config.shape === 'rect') {
                         ctx.rect(tower.x - towerSize, tower.y - towerSize, towerSize * 2, towerSize * 2);
                    } else if (config.shape === 'triangle') {
                        const triSize = towerSize * 1.3; // Adjust triangle size
                        ctx.moveTo(tower.x, tower.y - triSize * 0.8);
                        ctx.lineTo(tower.x - triSize, tower.y + triSize * 0.4);
                        ctx.lineTo(tower.x + triSize, tower.y + triSize * 0.4);
                        ctx.closePath();
                    } else { // Default circle
                         ctx.arc(tower.x, tower.y, towerSize, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    ctx.stroke();

                    // Draw selection indicator (range circle)
                    if (selectedTower === tower) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Draw upgrade level stars
                    if (tower.level > 1) {
                        ctx.fillStyle = 'yellow';
                        const starSize = 4;
                        const starSpacing = 6;
                        const totalWidth = (tower.level - 1) * starSpacing;
                        const startX = tower.x - totalWidth / 2 + starSize / 2; // Center stars
                        for (let i = 1; i < tower.level; i++) {
                            // Simple star shape (asterisk-like)
                            const starX = startX + (i - 1) * starSpacing;
                            const starY = tower.y - towerSize - 8; // Position above tower
                            ctx.fillText('*', starX - starSize / 2, starY + starSize / 2); // Adjust position slightly
                        }
                    }
                });
            }

             function drawTowerPlacementPreview() { /* Unchanged logic, uses TOWER_TYPES */
                const gridX = Math.floor(mouse.x / TILE_SIZE);
                const gridY = Math.floor(mouse.y / TILE_SIZE);
                if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT || !placingTowerType) return;

                const previewX = gridX * TILE_SIZE + TILE_SIZE / 2;
                const previewY = gridY * TILE_SIZE + TILE_SIZE / 2;
                const config = TOWER_TYPES[placingTowerType];
                if (!config) return;

                let canPlace = canPlaceTower(gridX, gridY, placingTowerType);

                ctx.globalAlpha = 0.5;
                ctx.fillStyle = canPlace ? config.color : 'red';
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                ctx.beginPath();
                 const previewSize = TILE_SIZE * 0.3;
                 if (config.shape === 'rect') {
                    ctx.rect(previewX - previewSize, previewY - previewSize, previewSize * 2, previewSize * 2);
                 } else if (config.shape === 'triangle') {
                     const triSize = previewSize * 1.3;
                     ctx.moveTo(previewX, previewY - triSize * 0.8);
                     ctx.lineTo(previewX - triSize, previewY + triSize * 0.4);
                     ctx.lineTo(previewX + triSize, previewY + triSize * 0.4);
                     ctx.closePath();
                 } else {
                    ctx.arc(previewX, previewY, previewSize, 0, Math.PI * 2);
                 }
                ctx.fill();
                ctx.stroke();

                // Draw range preview
                ctx.strokeStyle = canPlace ? 'rgba(255, 255, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(previewX, previewY, config.range, 0, Math.PI * 2);
                ctx.stroke();

                ctx.globalAlpha = 1.0;
            }

            function upgradeSelectedTower() {
                if (!selectedTower || selectedTower.level >= selectedTower.maxLevel) return;

                const towerConfig = TOWER_TYPES[selectedTower.type];
                const upgradeIndex = selectedTower.level - 1; // Index for upgrade costs/stats arrays
                if (upgradeIndex >= towerConfig.upgradeCosts.length) {
                    console.error("Upgrade config missing for level", selectedTower.level);
                    return;
                }

                const cost = towerConfig.upgradeCosts[upgradeIndex];
                if (money >= cost) {
                    money -= cost;
                    selectedTower.level++;
                    selectedTower.totalCost += cost; // Add upgrade cost to total investment

                    // Apply new stats from the upgradeStats array
                    const newStats = towerConfig.upgradeStats[upgradeIndex];
                    for (const stat in newStats) {
                        if (selectedTower.hasOwnProperty(stat)) {
                            selectedTower[stat] = newStats[stat];
                        }
                    }

                    console.log(`Tower upgraded to level ${selectedTower.level}`);
                    updateUI(); // Update button states and money display
                } else {
                    console.log("Not enough money to upgrade.");
                    // Optional: Show message to user
                }
            }

            function sellSelectedTower() {
                if (!selectedTower) return;

                const refund = Math.floor(selectedTower.totalCost * SELL_PERCENTAGE); // Refund based on total cost
                money += refund;

                const index = towers.indexOf(selectedTower);
                if (index > -1) towers.splice(index, 1);

                const gridX = selectedTower.gridX;
                const gridY = selectedTower.gridY;
                if (grid[gridY]?.[gridX]) {
                    grid[gridY][gridX].type = 'empty';
                    grid[gridY][gridX].tower = null;
                }

                selectedTower = null; // Deselect after selling
                updateUI();
            }


            // --- Projectile Handling --- (No changes needed for slow tower)
            function fireProjectile(tower, target) { /* Unchanged */
                projectiles.push({
                    x: tower.x, y: tower.y, damage: tower.damage, target: target,
                    speed: 6, size: 4,
                    color: TOWER_TYPES[tower.type]?.color || 'yellow'
                });
            }
            function handleProjectiles() { /* Unchanged */
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (!p.target || p.target.health <= 0) {
                        projectiles.splice(i, 1); continue;
                    }
                    const dx = p.target.x - p.x;
                    const dy = p.target.y - p.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < p.speed) {
                        p.target.health -= p.damage;
                        projectiles.splice(i, 1);
                    } else {
                        p.x += (dx / distance) * p.speed;
                        p.y += (dy / distance) * p.speed;
                    }
                }
            }
            function drawProjectiles() { /* Unchanged */
                projectiles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // --- Wave Management ---
            function startWave() { /* Unchanged */
                if (waveInProgress || gameOver) return;
                wave++;
                enemiesToSpawn = 8 + wave * 3;
                spawnTimer = ENEMY_SPAWN_INTERVAL;
                waveInProgress = true;
                deselectPlacedTower();
                updateUI();
            }
            function handleWaves() { /* Unchanged */
                if (!waveInProgress) {
                     if (wave === 0 && frameCount > WAVE_START_DELAY && !gameOver) startWave();
                    return;
                }
                if (enemiesToSpawn > 0 && spawnTimer <= 0) {
                    spawnEnemy();
                    enemiesToSpawn--;
                    spawnTimer = ENEMY_SPAWN_INTERVAL;
                }
                spawnTimer--;
                if (enemiesToSpawn <= 0 && enemies.length === 0) {
                    waveInProgress = false;
                    money += 50 + wave * 10;
                    updateUI();
                }
            }

            // --- UI and Interaction ---
            function updateUI() {
                moneyDisplay.textContent = money;
                scoreDisplay.textContent = score;
                livesDisplay.textContent = lives;
                waveDisplay.textContent = wave;

                // Update tower purchase buttons state
                towerButtons.forEach(btn => {
                    const type = btn.dataset.type;
                    const config = TOWER_TYPES[type];
                    if (!config) return;
                    const cost = config.cost;
                    const disabled = money < cost || gameOver; // Disable purchase if game over
                    btn.disabled = disabled;
                    btn.classList.toggle('disabled', disabled);
                    btn.classList.toggle('selected', placingTowerType === type);
                    // Update button text to include cost
                    btn.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (${cost}$)`;
                });

                // Update Start Wave button state
                startWaveBtn.disabled = waveInProgress || gameOver;
                startWaveBtn.classList.toggle('disabled', waveInProgress || gameOver);

                // Update Sell and Upgrade button states based on selectedTower
                let canSell = false;
                let canUpgrade = false;
                let sellAmount = 0;
                let upgradeCost = 0;

                if (selectedTower && !gameOver) {
                    canSell = true;
                    sellAmount = Math.floor(selectedTower.totalCost * SELL_PERCENTAGE);

                    if (selectedTower.level < selectedTower.maxLevel) {
                         const towerConfig = TOWER_TYPES[selectedTower.type];
                         const upgradeIndex = selectedTower.level - 1;
                         if (upgradeIndex < towerConfig.upgradeCosts.length) {
                            upgradeCost = towerConfig.upgradeCosts[upgradeIndex];
                            if (money >= upgradeCost) {
                                canUpgrade = true;
                            }
                         }
                    }
                }

                sellTowerBtn.disabled = !canSell;
                sellTowerBtn.classList.toggle('disabled', !canSell);
                sellTowerBtn.textContent = `Sell (${sellAmount}$)`; // Show sell amount

                upgradeTowerBtn.disabled = !canUpgrade;
                upgradeTowerBtn.classList.toggle('disabled', !canUpgrade);
                upgradeTowerBtn.textContent = canUpgrade || (selectedTower && selectedTower.level < selectedTower.maxLevel) ? `Upgrade (${upgradeCost}$) ` : 'Max Level'; // Show cost or Max
                 // Ensure buttons are hidden if no tower selected, even if technically enabled
                 sellTowerBtn.style.display = selectedTower ? 'inline-block' : 'none';
                 upgradeTowerBtn.style.display = selectedTower ? 'inline-block' : 'none';

            }

            function setupEventListeners() {
                startWaveBtn.addEventListener('click', startWave);
                sellTowerBtn.addEventListener('click', sellSelectedTower);
                upgradeTowerBtn.addEventListener('click', upgradeSelectedTower);

                // Tower Purchase Buttons
                towerButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const type = btn.dataset.type;
                        const config = TOWER_TYPES[type];
                        if (config) selectTowerPurchase(type, config.cost);
                    });
                });

                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseleave', () => { if (placingTowerType) mouse = { x: -1, y: -1 }; });

                 document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        deselectTowerPurchase();
                        deselectPlacedTower();
                    }
                });
                 document.addEventListener('click', (event) => {
                    if (!canvas.contains(event.target) && !event.target.closest('.controls')) {
                       deselectPlacedTower();
                    }
                 });

                messageBtn.addEventListener('click', hideMessage);
            }

             function selectTowerPurchase(type, cost) { /* Logic unchanged */
                 if (money >= cost && !gameOver) { // Prevent purchase if game over
                    placingTowerType = type;
                    deselectPlacedTower();
                    updateUI();
                 } else {
                     console.log("Not enough money or game over.");
                     deselectTowerPurchase();
                 }
            }

            function deselectTowerPurchase() { /* Logic unchanged */
                placingTowerType = null;
                towerButtons.forEach(btn => btn.classList.remove('selected'));
                updateUI(); // Update button states (needed if selection changes)
            }

            function selectPlacedTower(tower) { /* Logic unchanged */
                selectedTower = tower;
                deselectTowerPurchase();
                updateUI();
            }

            function deselectPlacedTower() { /* Logic unchanged */
                if (selectedTower) { // Only update if something was selected
                    selectedTower = null;
                    updateUI();
                }
            }

            function handleCanvasClick(event) { /* Logic unchanged */
                const rect = canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                const gridX = Math.floor(clickX / TILE_SIZE);
                const gridY = Math.floor(clickY / TILE_SIZE);

                if (placingTowerType) {
                    placeTower(gridX, gridY);
                } else {
                    const clickedTower = grid[gridY]?.[gridX]?.tower;
                    if (clickedTower) {
                        if (selectedTower === clickedTower) deselectPlacedTower();
                        else selectPlacedTower(clickedTower);
                    } else {
                        deselectPlacedTower();
                    }
                }
            }

            function handleMouseMove(event) { /* Logic unchanged */
                 if (placingTowerType) {
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = event.clientX - rect.left;
                    mouse.y = event.clientY - rect.top;
                 } else {
                    mouse = { x: -1, y: -1 };
                 }
            }

            // --- Utility Functions ---
            function getDistance(obj1, obj2) { /* Unchanged */
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // --- Game Over / Message ---
            function endGame(win) { /* Logic unchanged */
                gameOver = true;
                waveInProgress = false;
                placingTowerType = null;
                selectedTower = null;
                const message = win ? `Wave Cleared! You Won! Final Score: ${score}` : `Game Over! Score: ${score}, Wave: ${wave}`;
                showMessage(message);
                updateUI();
            }
            function showMessage(text) { /* Logic unchanged */
                messageText.textContent = text;
                messageBox.style.display = 'block';
                gamePaused = true;
            }
            function hideMessage() { /* Logic unchanged */
                messageBox.style.display = 'none';
                 gamePaused = false;
                 if (!gameOver) requestAnimationFrame(gameLoop);
            }

            // --- Start the Game ---
            gameLoop();
        };
    </script>
</body>
</html>
