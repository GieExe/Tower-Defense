<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Tower Defense V4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            overflow: hidden;
        }
        canvas {
            background-color: #333;
            display: block;
            border: 4px solid #555;
            border-radius: 8px;
            margin: 0 auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            cursor: pointer;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 20px;
        }
        .controls, .stats {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #555;
            margin-bottom: 20px;
            width: 100%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            font-size: 0.9em;
            text-align: left;
        }
        /* Control Groups */
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .control-group:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .control-group h3 {
             font-size: 0.9em;
             margin-bottom: 10px;
             color: #aaa;
             text-transform: uppercase;
        }

        /* Buttons General */
        .controls button, .tower-button, .target-button {
            font-family: 'Press Start 2P', cursive;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            margin: 5px;
            border-bottom: 3px solid #555;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            vertical-align: middle;
            font-size: 0.8em;
        }
        .controls button:hover, .tower-button:hover, .target-button:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-1px);
        }
        .controls button:active, .tower-button:active, .target-button:active {
            transform: translateY(1px);
            border-bottom-width: 1px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Specific Button Colors */
        #startWaveBtn { background-color: #28a745; border-bottom-color: #1e7e34; }
        #startWaveBtn:hover { background-color: #218838; }
        #sellTowerBtn { background-color: #dc3545; border-bottom-color: #a71d2a; }
        #sellTowerBtn:hover { background-color: #c82333; }
        #upgradeTowerBtn { background-color: #ffc107; border-bottom-color: #ba8b00; color: #333;}
        #upgradeTowerBtn:hover { background-color: #e0a800; }

        /* Tower Purchase Buttons */
        #basicTowerBtn { background-color: #17a2b8; border-bottom-color: #117a8b; } /* Cyan */
        #basicTowerBtn:hover { background-color: #138496; }
        #laserTowerBtn { background-color: #fd7e14; border-bottom-color: #c75e0a; } /* Orange */
        #laserTowerBtn:hover { background-color: #e66e0c; }
        #slowTowerBtn { background-color: #6495ED; border-bottom-color: #4169E1; } /* Blue */
        #slowTowerBtn:hover { background-color: #4682B4; }
        #splashTowerBtn { background-color: #800080; border-bottom-color: #4B0082; } /* Purple */
        #splashTowerBtn:hover { background-color: #6A0DAD; }


        /* Targeting Buttons */
        .target-button {
            padding: 5px 8px; /* Smaller padding */
            font-size: 0.7em; /* Smaller font */
            background-color: #444;
            border-bottom-color: #222;
        }
        .target-button:hover {
             background-color: #555;
        }
        .target-button.active {
            background-color: #007bff; /* Blue indicates active target */
            border-bottom-color: #0056b3;
            box-shadow: 0 0 5px #0ff;
        }

        /* Disabled / Selection States */
        .tower-button.selected {
            box-shadow: 0 0 10px 3px #0ff;
            transform: scale(1.05);
        }
        .tower-button.disabled, #sellTowerBtn.disabled, #startWaveBtn.disabled, #upgradeTowerBtn.disabled, .target-button.disabled {
            background-color: #6c757d !important; /* Use important to override specific styles */
            cursor: not-allowed;
            border-bottom-color: #545b62 !important;
            box-shadow: none;
            transform: none;
            color: #ccc !important;
        }
        /* Hide action buttons initially */
        #towerActions, #targetingControls { display: none; }
        #towerActions.visible, #targetingControls.visible { display: block; }


        .message-box { /* Unchanged */
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); color: white;
            padding: 30px 40px; border-radius: 10px;
            font-size: 1.5em; text-align: center; z-index: 100;
            border: 3px solid #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            display: none;
        }
        .message-box button { /* Unchanged */
             font-family: 'Press Start 2P', cursive; background-color: #007bff;
            color: white; border: none; padding: 10px 15px;
            border-radius: 5px; cursor: pointer; transition: background-color 0.3s;
            margin-top: 20px; border-bottom: 3px solid #0056b3;
        }
         .message-box button:hover { background-color: #0056b3; }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-3xl mb-4 text-cyan-300 text-center">Pixel Tower Defense V4</h1>

        <div class="stats" id="stats">
            <span>Money: <span id="money">120</span></span>
            <span>Score: <span id="score">0</span></span>
            <span>Lives: <span id="lives">10</span></span>
            <span>Wave: <span id="wave">0</span></span>
        </div>

        <div class="controls text-center">
            <div class="control-group">
                <h3>Towers</h3>
                <button id="basicTowerBtn" class="tower-button" data-type="basic">Basic</button>
                <button id="laserTowerBtn" class="tower-button" data-type="laser">Laser</button>
                <button id="slowTowerBtn" class="tower-button" data-type="slow">Slow</button>
                <button id="splashTowerBtn" class="tower-button" data-type="splash">Splash</button>
            </div>

             <div class="control-group">
                 <h3>Game</h3>
                 <button id="startWaveBtn">Start Next Wave</button>
            </div>

             <div id="towerActions" class="control-group">
                 <h3>Tower Actions</h3>
                 <button id="upgradeTowerBtn" class="disabled">Upgrade</button>
                 <button id="sellTowerBtn" class="disabled">Sell</button>
             </div>

             <div id="targetingControls" class="control-group">
                 <h3>Target Priority</h3>
                 <button class="target-button" data-priority="first">First</button>
                 <button class="target-button" data-priority="last">Last</button>
                 <button class="target-button" data-priority="strongest">Strongest</button>
                 <button class="target-button" data-priority="weakest">Weakest</button>
             </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button id="messageBtn">OK</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- Game Configuration ---
            const TILE_SIZE = 40;
            const GRID_WIDTH = canvas.width / TILE_SIZE;
            const GRID_HEIGHT = canvas.height / TILE_SIZE;
            const STARTING_MONEY = 120;
            const STARTING_LIVES = 10;
            const WAVE_START_DELAY = 300;
            const ENEMY_SPAWN_INTERVAL = 60; // Frames between spawns
            const SELL_PERCENTAGE = 0.7;

            // Enemy Config
            const ENEMY_START_HEALTH = 30;
            const ENEMY_SPEED = 1;
            const ENEMY_HEALTH_INCREMENT = 15; // Per wave after wave 1

            // --- Tower Configuration ---
            const TOWER_TYPES = {
                'basic': {
                    cost: 50, range: 100, damage: 12, fireRate: 50, color: '#17a2b8', shape: 'rect', maxLevel: 2,
                    upgradeCosts: [75], upgradeStats: [{ damage: 18, range: 110 }]
                },
                'laser': {
                    cost: 75, range: 90, damage: 7, fireRate: 25, color: '#fd7e14', shape: 'triangle', maxLevel: 2,
                    upgradeCosts: [100], upgradeStats: [{ damage: 10, fireRate: 20 }]
                },
                'slow': {
                    cost: 60, range: 80, damage: 0, fireRate: 30, color: '#6495ED', shape: 'circle', maxLevel: 2,
                    slowFactor: 0.6, slowDuration: 120,
                    upgradeCosts: [70], upgradeStats: [{ range: 95, slowFactor: 0.5 }]
                },
                'splash': {
                    cost: 90, range: 90, damage: 8, fireRate: 60, color: '#800080', shape: 'circle', maxLevel: 2,
                    splashRadius: 40, // Pixels
                    upgradeCosts: [120], upgradeStats: [{ damage: 12, splashRadius: 50 }]
                }
            };

            // --- Game State ---
            let money = STARTING_MONEY;
            let score = 0;
            let lives = STARTING_LIVES;
            let wave = 0;
            let enemies = [];
            let towers = [];
            let projectiles = [];
            let effects = []; // For visual effects like splash impacts
            let grid = createGrid();
            let path = [];
            let placingTowerType = null;
            let selectedTower = null;
            let mouse = { x: 0, y: 0 };
            let waveInProgress = false;
            let enemiesToSpawn = 0;
            let spawnTimer = 0;
            let frameCount = 0;
            let gameOver = false;
            let gamePaused = false;

            // --- UI Elements ---
            const moneyDisplay = document.getElementById('money');
            const scoreDisplay = document.getElementById('score');
            const livesDisplay = document.getElementById('lives');
            const waveDisplay = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn');
            const sellTowerBtn = document.getElementById('sellTowerBtn');
            const upgradeTowerBtn = document.getElementById('upgradeTowerBtn');
            const towerButtons = document.querySelectorAll('.tower-button');
            const targetButtons = document.querySelectorAll('.target-button');
            const towerActionsDiv = document.getElementById('towerActions');
            const targetingControlsDiv = document.getElementById('targetingControls');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const messageBtn = document.getElementById('messageBtn');

            // --- Path Definition ---
            const pathPoints = [ { x: 0, y: 2 }, { x: 3, y: 2 }, { x: 3, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 4 }, { x: 14, y: 4 } ];
            calculatePixelPath();

            // --- Initialization ---
            updateUI();
            setupEventListeners();

            // --- Game Loop ---
            function gameLoop() {
                if (gameOver || gamePaused) {
                     if (!gameOver) requestAnimationFrame(gameLoop);
                     return;
                }
                frameCount++;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                drawGrid();
                drawPath();
                handleWaves();
                handleEnemies();
                handleTowers();
                handleProjectiles();
                handleEffects(); // Update and draw effects

                drawTowers();
                drawEnemies();
                drawProjectiles();
                drawEffects(); // Draw effects on top

                if (placingTowerType) {
                    drawTowerPlacementPreview();
                }
                requestAnimationFrame(gameLoop);
            }

            // --- Grid and Path --- (Unchanged)
            function createGrid() { /*...*/
                const newGrid = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    newGrid[y] = [];
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        newGrid[y][x] = { type: 'empty', tower: null };
                    }
                }
                return newGrid;
             }
            function calculatePixelPath() { /*...*/
                 path = [];
                if (pathPoints.length === 0) return;
                // Calculate distance for each segment for targeting priority 'first'/'last'
                let totalDistance = 0;
                const waypoints = [];
                waypoints.push({ x: pathPoints[0].x * TILE_SIZE - TILE_SIZE, y: pathPoints[0].y * TILE_SIZE + TILE_SIZE / 2, dist: 0 }); // Start off-screen

                for (let i = 0; i < pathPoints.length; i++) {
                    const point = pathPoints[i];
                    const x = point.x * TILE_SIZE + TILE_SIZE / 2;
                    const y = point.y * TILE_SIZE + TILE_SIZE / 2;
                    const prevWaypoint = waypoints[waypoints.length - 1];
                    const segmentDist = getDistance(prevWaypoint, {x, y});
                    totalDistance += segmentDist;
                    waypoints.push({ x, y, dist: totalDistance }); // Store cumulative distance

                    // Mark grid cells as path (same as before)
                     if (i > 0) {
                        const prevPoint = pathPoints[i - 1];
                        if (point.x === prevPoint.x) {
                            const startY = Math.min(point.y, prevPoint.y);
                            const endY = Math.max(point.y, prevPoint.y);
                            for (let py = startY; py <= endY; py++) {
                                if (grid[py]?.[point.x]) grid[py][point.x].type = 'path';
                            }
                        } else {
                            const startX = Math.min(point.x, prevPoint.x);
                            const endX = Math.max(point.x, prevPoint.x);
                            for (let px = startX; px <= endX; px++) {
                                if (grid[point.y]?.[px]) grid[point.y][px].type = 'path';
                            }
                        }
                    } else {
                         if (grid[point.y]?.[point.x]) grid[point.y][point.x].type = 'path';
                    }
                }
                const lastGridPoint = pathPoints[pathPoints.length - 1];
                const endX = (lastGridPoint.x + 1) * TILE_SIZE + TILE_SIZE;
                const endY = lastGridPoint.y * TILE_SIZE + TILE_SIZE / 2;
                const lastWaypoint = waypoints[waypoints.length-1];
                totalDistance += getDistance(lastWaypoint, {x: endX, y: endY});
                waypoints.push({ x: endX, y: endY, dist: totalDistance }); // End off-screen

                path = waypoints; // Use the waypoints array with distance info
             }
            function drawGrid() { /*...*/ ctx.strokeStyle = '#383838'; ctx.lineWidth = 1; for (let y = 0; y < GRID_HEIGHT; y++) for (let x = 0; x < GRID_WIDTH; x++) ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }
            function drawPath() { /*...*/ ctx.strokeStyle = '#888'; ctx.lineWidth = TILE_SIZE * 0.8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); if (path.length > 0) { ctx.moveTo(path[0].x, path[0].y); for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y); } ctx.stroke(); }

             // --- Enemy Handling ---
            function spawnEnemy() { /*...*/
                const health = ENEMY_START_HEALTH + (wave - 1) * ENEMY_HEALTH_INCREMENT;
                enemies.push({
                    x: path[0].x, y: path[0].y, health: health, maxHealth: health,
                    speed: ENEMY_SPEED, pathIndex: 1, size: TILE_SIZE * 0.4,
                    speedMultiplier: 1, slowTimer: 0,
                    distanceTraveled: 0 // For 'first'/'last' targeting
                });
             }
            function handleEnemies() { /*...*/
                 for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (enemy.slowTimer > 0) { enemy.slowTimer--; if (enemy.slowTimer <= 0) enemy.speedMultiplier = 1; }

                    const effectiveSpeed = enemy.speed * enemy.speedMultiplier;
                    if (enemy.pathIndex < path.length) {
                        const targetPoint = path[enemy.pathIndex];
                        const dx = targetPoint.x - enemy.x;
                        const dy = targetPoint.y - enemy.y;
                        const distanceToWaypoint = Math.sqrt(dx * dx + dy * dy);
                        let moveDistance = Math.min(effectiveSpeed, distanceToWaypoint);

                        enemy.x += (dx / distanceToWaypoint) * moveDistance;
                        enemy.y += (dy / distanceToWaypoint) * moveDistance;
                        enemy.distanceTraveled += moveDistance; // Update distance traveled

                        if (distanceToWaypoint <= effectiveSpeed) {
                            enemy.pathIndex++;
                        }
                    } else {
                        lives--; updateUI(); enemies.splice(i, 1); if (lives <= 0) endGame(false); continue;
                    }
                    if (enemy.health <= 0) {
                        money += 5 + Math.floor(wave / 5); score += 10; updateUI(); enemies.splice(i, 1);
                    }
                }
             }
            function drawEnemies() { /*...*/
                enemies.forEach(enemy => {
                    ctx.fillStyle = '#28a745'; ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = enemy.speedMultiplier < 1 ? '#007bff' : '#1e7e34'; ctx.lineWidth = 2; ctx.stroke();
                    const healthBarWidth = enemy.size * 2; const healthBarHeight = 5; const healthPercentage = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#555'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - healthBarHeight - 3, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = '#dc3545'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - healthBarHeight - 3, healthBarWidth * healthPercentage, healthBarHeight);
                });
             }

            // --- Tower Handling ---
             function canPlaceTower(gridX, gridY, towerType) { /*...*/ const config = TOWER_TYPES[towerType]; if (!config || !grid[gridY]?.[gridX] || grid[gridY][gridX].type !== 'empty' || money < config.cost) return false; return true; }
             function placeTower(gridX, gridY) { /*...*/
                 if (!placingTowerType) return;
                 const config = TOWER_TYPES[placingTowerType];
                 if (!config || !canPlaceTower(gridX, gridY, placingTowerType)) return;

                 money -= config.cost;
                 const towerX = gridX * TILE_SIZE + TILE_SIZE / 2;
                 const towerY = gridY * TILE_SIZE + TILE_SIZE / 2;
                 const newTower = {
                     x: towerX, y: towerY, gridX: gridX, gridY: gridY,
                     range: config.range, damage: config.damage, fireRate: config.fireRate,
                     slowFactor: config.slowFactor, slowDuration: config.slowDuration,
                     splashRadius: config.splashRadius, // Add splash radius
                     fireCooldown: 0, target: null, type: placingTowerType,
                     level: 1, maxLevel: config.maxLevel, totalCost: config.cost,
                     targetingPriority: 'first' // Default targeting priority
                 };
                 towers.push(newTower);
                 grid[gridY][gridX].type = 'tower';
                 grid[gridY][gridX].tower = newTower;
                 deselectTowerPurchase(); updateUI();
              }

            function handleTowers() {
                towers.forEach(tower => {
                    if (tower.fireCooldown > 0) tower.fireCooldown--;

                    // Find target based on priority if needed
                    if (!tower.target || tower.target.health <= 0 || getDistance(tower, tower.target) > tower.range) {
                        tower.target = findTargetBasedOnPriority(tower); // Use new targeting function
                    }

                    // Act if cooldown ready and target exists
                    if (tower.fireCooldown <= 0 && tower.target) {
                        if (tower.type === 'slow') {
                            applySlowEffect(tower);
                            tower.fireCooldown = tower.fireRate;
                        } else if (tower.damage > 0) {
                            fireProjectile(tower, tower.target);
                            tower.fireCooldown = tower.fireRate;
                        }
                    }
                });
            }

            function applySlowEffect(tower) { /*...*/ enemies.forEach(enemy => { if (getDistance(tower, enemy) <= tower.range) { enemy.speedMultiplier = tower.slowFactor; enemy.slowTimer = tower.slowDuration; } }); }

            // --- Targeting Logic ---
            function findTargetBasedOnPriority(tower) {
                let potentialTargets = enemies.filter(enemy => getDistance(tower, enemy) <= tower.range);
                if (potentialTargets.length === 0) return null;

                switch (tower.targetingPriority) {
                    case 'first': // Enemy furthest along the path
                        potentialTargets.sort((a, b) => b.distanceTraveled - a.distanceTraveled);
                        break;
                    case 'last': // Enemy least far along the path
                         potentialTargets.sort((a, b) => a.distanceTraveled - b.distanceTraveled);
                        break;
                    case 'strongest': // Highest current health
                        potentialTargets.sort((a, b) => b.health - a.health);
                        break;
                    case 'weakest': // Lowest current health
                        potentialTargets.sort((a, b) => a.health - b.health);
                        break;
                    default: // Default to 'first' if something is wrong
                        potentialTargets.sort((a, b) => b.distanceTraveled - a.distanceTraveled);
                        break;
                }
                return potentialTargets[0]; // Return the best target based on sorted list
            }


            function drawTowers() { /*...*/
                 towers.forEach(tower => {
                    const config = TOWER_TYPES[tower.type];
                    ctx.fillStyle = config.color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.beginPath();
                    const towerSize = TILE_SIZE * 0.3 + (tower.level - 1) * 2;

                    if (config.shape === 'rect') { ctx.rect(tower.x - towerSize, tower.y - towerSize, towerSize * 2, towerSize * 2); }
                    else if (config.shape === 'triangle') { const triSize = towerSize * 1.3; ctx.moveTo(tower.x, tower.y - triSize * 0.8); ctx.lineTo(tower.x - triSize, tower.y + triSize * 0.4); ctx.lineTo(tower.x + triSize, tower.y + triSize * 0.4); ctx.closePath(); }
                    else if (tower.type === 'splash') { // Custom shape for splash
                        ctx.arc(tower.x, tower.y, towerSize, 0, Math.PI * 2); // Outer circle
                        ctx.moveTo(tower.x + towerSize * 0.6, tower.y);
                        ctx.arc(tower.x, tower.y, towerSize * 0.6, 0, Math.PI * 2); // Inner circle
                    }
                    else { ctx.arc(tower.x, tower.y, towerSize, 0, Math.PI * 2); } // Default circle

                    ctx.fill(); ctx.stroke();

                    if (selectedTower === tower) { ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2); ctx.stroke(); }

                    if (tower.level > 1) {
                        ctx.fillStyle = 'yellow'; ctx.font = `${TILE_SIZE * 0.4}px 'Press Start 2P'`; // Ensure font is set
                        const starSize = 4; const starSpacing = 6; const totalWidth = (tower.level - 1) * starSpacing;
                        const startX = tower.x - totalWidth / 2 + starSize / 2;
                        for (let i = 1; i < tower.level; i++) {
                            const starX = startX + (i - 1) * starSpacing; const starY = tower.y - towerSize - 8;
                            ctx.fillText('*', starX - starSize / 2, starY + starSize / 2);
                        }
                    }
                });
             }
            function drawTowerPlacementPreview() { /*...*/
                 const gridX = Math.floor(mouse.x / TILE_SIZE); const gridY = Math.floor(mouse.y / TILE_SIZE);
                 if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT || !placingTowerType) return;
                 const previewX = gridX * TILE_SIZE + TILE_SIZE / 2; const previewY = gridY * TILE_SIZE + TILE_SIZE / 2;
                 const config = TOWER_TYPES[placingTowerType]; if (!config) return;
                 let canPlace = canPlaceTower(gridX, gridY, placingTowerType);
                 ctx.globalAlpha = 0.5; ctx.fillStyle = canPlace ? config.color : 'red'; ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.beginPath();
                 const previewSize = TILE_SIZE * 0.3;
                 if (config.shape === 'rect') { ctx.rect(previewX - previewSize, previewY - previewSize, previewSize * 2, previewSize * 2); }
                 else if (config.shape === 'triangle') { const triSize = previewSize * 1.3; ctx.moveTo(previewX, previewY - triSize * 0.8); ctx.lineTo(previewX - triSize, previewY + triSize * 0.4); ctx.lineTo(previewX + triSize, previewY + triSize * 0.4); ctx.closePath(); }
                 else if (placingTowerType === 'splash') { ctx.arc(previewX, previewY, previewSize, 0, Math.PI * 2); ctx.moveTo(previewX + previewSize * 0.6, previewY); ctx.arc(previewX, previewY, previewSize * 0.6, 0, Math.PI * 2); }
                 else { ctx.arc(previewX, previewY, previewSize, 0, Math.PI * 2); }
                 ctx.fill(); ctx.stroke();
                 ctx.strokeStyle = canPlace ? 'rgba(255, 255, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(previewX, previewY, config.range, 0, Math.PI * 2); ctx.stroke();
                 ctx.globalAlpha = 1.0;
             }
            function upgradeSelectedTower() { /*...*/
                 if (!selectedTower || selectedTower.level >= selectedTower.maxLevel) return;
                 const towerConfig = TOWER_TYPES[selectedTower.type]; const upgradeIndex = selectedTower.level - 1;
                 if (upgradeIndex >= towerConfig.upgradeCosts.length) { console.error("Upgrade config missing"); return; }
                 const cost = towerConfig.upgradeCosts[upgradeIndex];
                 if (money >= cost) {
                     money -= cost; selectedTower.level++; selectedTower.totalCost += cost;
                     const newStats = towerConfig.upgradeStats[upgradeIndex];
                     for (const stat in newStats) { if (selectedTower.hasOwnProperty(stat)) selectedTower[stat] = newStats[stat]; }
                     console.log(`Upgraded to Lvl ${selectedTower.level}`); updateUI();
                 } else { console.log("Not enough money"); }
             }
            function sellSelectedTower() { /*...*/
                 if (!selectedTower) return;
                 const refund = Math.floor(selectedTower.totalCost * SELL_PERCENTAGE); money += refund;
                 const index = towers.indexOf(selectedTower); if (index > -1) towers.splice(index, 1);
                 const gridX = selectedTower.gridX; const gridY = selectedTower.gridY;
                 if (grid[gridY]?.[gridX]) { grid[gridY][gridX].type = 'empty'; grid[gridY][gridX].tower = null; }
                 selectedTower = null; updateUI();
             }

            // --- Projectile Handling ---
            function fireProjectile(tower, target) { /*...*/
                 projectiles.push({
                     x: tower.x, y: tower.y, damage: tower.damage, target: target,
                     speed: 6, size: 4, color: TOWER_TYPES[tower.type]?.color || 'yellow',
                     type: tower.type, // Store tower type for splash check
                     splashRadius: tower.splashRadius // Store splash radius
                 });
             }
            function handleProjectiles() {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (!p.target || p.target.health <= 0) {
                        projectiles.splice(i, 1); continue; // Target gone
                    }

                    const dx = p.target.x - p.x;
                    const dy = p.target.y - p.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < p.speed) { // Hit target
                        if (p.type === 'splash') {
                            // Apply splash damage
                            enemies.forEach(enemy => {
                                if (getDistance(p.target, enemy) <= p.splashRadius) { // Check distance from impact point (target)
                                    enemy.health -= p.damage;
                                }
                            });
                            // Add splash visual effect at target location
                             addEffect(p.target.x, p.target.y, p.splashRadius, p.color || TOWER_TYPES['splash'].color);
                        } else {
                            // Apply single target damage
                            p.target.health -= p.damage;
                        }
                        projectiles.splice(i, 1); // Remove projectile
                    } else {
                        // Move projectile
                        p.x += (dx / distance) * p.speed;
                        p.y += (dy / distance) * p.speed;
                    }
                }
            }
            function drawProjectiles() { /*...*/ projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); }

             // --- Visual Effects Handling ---
             function addEffect(x, y, radius, color) {
                 effects.push({ x, y, maxRadius: radius, currentRadius: 0, duration: 20, timer: 20, color: color || 'rgba(255, 255, 0, 0.5)' }); // 20 frames duration
             }
             function handleEffects() {
                 for (let i = effects.length - 1; i >= 0; i--) {
                     const effect = effects[i];
                     effect.timer--;
                     effect.currentRadius = effect.maxRadius * (1 - (effect.timer / effect.duration)); // Expand outwards
                     if (effect.timer <= 0) {
                         effects.splice(i, 1); // Remove finished effects
                     }
                 }
             }
             function drawEffects() {
                 effects.forEach(effect => {
                     ctx.beginPath();
                     ctx.arc(effect.x, effect.y, effect.currentRadius, 0, Math.PI * 2);
                     ctx.strokeStyle = effect.color;
                     ctx.lineWidth = 2;
                     ctx.globalAlpha = effect.timer / effect.duration; // Fade out
                     ctx.stroke();
                     ctx.globalAlpha = 1.0; // Reset alpha
                 });
             }


            // --- Wave Management --- (Unchanged)
            function startWave() { /*...*/ if (waveInProgress || gameOver) return; wave++; enemiesToSpawn = 8 + wave * 3; spawnTimer = ENEMY_SPAWN_INTERVAL; waveInProgress = true; deselectPlacedTower(); updateUI(); }
            function handleWaves() { /*...*/ if (!waveInProgress) { if (wave === 0 && frameCount > WAVE_START_DELAY && !gameOver) startWave(); return; } if (enemiesToSpawn > 0 && spawnTimer <= 0) { spawnEnemy(); enemiesToSpawn--; spawnTimer = ENEMY_SPAWN_INTERVAL; } spawnTimer--; if (enemiesToSpawn <= 0 && enemies.length === 0) { waveInProgress = false; money += 50 + wave * 10; updateUI(); } }

            // --- UI and Interaction ---
            function updateUI() { /*...*/
                moneyDisplay.textContent = money; scoreDisplay.textContent = score; livesDisplay.textContent = lives; waveDisplay.textContent = wave;

                towerButtons.forEach(btn => {
                    const type = btn.dataset.type; const config = TOWER_TYPES[type]; if (!config) return; const cost = config.cost;
                    const disabled = money < cost || gameOver; btn.disabled = disabled; btn.classList.toggle('disabled', disabled); btn.classList.toggle('selected', placingTowerType === type);
                    btn.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} (${cost}$)`;
                });

                startWaveBtn.disabled = waveInProgress || gameOver; startWaveBtn.classList.toggle('disabled', waveInProgress || gameOver);

                let canSell = false; let canUpgrade = false; let sellAmount = 0; let upgradeCost = 0;
                let currentPriority = null;

                if (selectedTower && !gameOver) {
                    canSell = true; sellAmount = Math.floor(selectedTower.totalCost * SELL_PERCENTAGE);
                    currentPriority = selectedTower.targetingPriority;

                    if (selectedTower.level < selectedTower.maxLevel) {
                         const towerConfig = TOWER_TYPES[selectedTower.type]; const upgradeIndex = selectedTower.level - 1;
                         if (upgradeIndex < towerConfig.upgradeCosts.length) {
                            upgradeCost = towerConfig.upgradeCosts[upgradeIndex];
                            if (money >= upgradeCost) canUpgrade = true;
                         }
                    }
                }

                // Update action buttons visibility and state
                towerActionsDiv.classList.toggle('visible', !!selectedTower);
                sellTowerBtn.disabled = !canSell; sellTowerBtn.textContent = `Sell (${sellAmount}$)`;
                upgradeTowerBtn.disabled = !canUpgrade; upgradeTowerBtn.textContent = (selectedTower && selectedTower.level >= selectedTower.maxLevel) ? 'Max Level' : `Upgrade (${upgradeCost}$)`;

                // Update targeting controls visibility and state
                targetingControlsDiv.classList.toggle('visible', !!selectedTower);
                targetButtons.forEach(btn => {
                    if (selectedTower) {
                        btn.classList.toggle('active', btn.dataset.priority === currentPriority);
                        btn.disabled = gameOver; // Disable targeting changes if game over
                        btn.classList.toggle('disabled', gameOver);
                    } else {
                        btn.classList.remove('active');
                         btn.disabled = true; // Disable if no tower selected
                         btn.classList.add('disabled');
                    }
                });
             }

            function setupEventListeners() { /*...*/
                startWaveBtn.addEventListener('click', startWave);
                sellTowerBtn.addEventListener('click', sellSelectedTower);
                upgradeTowerBtn.addEventListener('click', upgradeSelectedTower);

                towerButtons.forEach(btn => { btn.addEventListener('click', () => { const type = btn.dataset.type; const config = TOWER_TYPES[type]; if (config) selectTowerPurchase(type, config.cost); }); });
                targetButtons.forEach(btn => { btn.addEventListener('click', () => { if (selectedTower && !btn.disabled) { selectedTower.targetingPriority = btn.dataset.priority; updateUI(); } }); }); // Update priority on click

                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseleave', () => { if (placingTowerType) mouse = { x: -1, y: -1 }; });

                 document.addEventListener('keydown', (event) => { if (event.key === 'Escape') { deselectTowerPurchase(); deselectPlacedTower(); } });
                 document.addEventListener('click', (event) => { if (!canvas.contains(event.target) && !event.target.closest('.controls')) { deselectPlacedTower(); } });

                messageBtn.addEventListener('click', hideMessage);
             }

             function selectTowerPurchase(type, cost) { /*...*/ if (money >= cost && !gameOver) { placingTowerType = type; deselectPlacedTower(); updateUI(); } else { console.log("Not enough money or game over."); deselectTowerPurchase(); } }
             function deselectTowerPurchase() { /*...*/ placingTowerType = null; towerButtons.forEach(btn => btn.classList.remove('selected')); updateUI(); }
             function selectPlacedTower(tower) { /*...*/ selectedTower = tower; deselectTowerPurchase(); updateUI(); }
             function deselectPlacedTower() { /*...*/ if (selectedTower) { selectedTower = null; updateUI(); } }
             function handleCanvasClick(event) { /*...*/ const rect = canvas.getBoundingClientRect(); const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top; const gridX = Math.floor(clickX / TILE_SIZE); const gridY = Math.floor(clickY / TILE_SIZE); if (placingTowerType) { placeTower(gridX, gridY); } else { const clickedTower = grid[gridY]?.[gridX]?.tower; if (clickedTower) { if (selectedTower === clickedTower) deselectPlacedTower(); else selectPlacedTower(clickedTower); } else { deselectPlacedTower(); } } }
             function handleMouseMove(event) { /*...*/ if (placingTowerType) { const rect = canvas.getBoundingClientRect(); mouse.x = event.clientX - rect.left; mouse.y = event.clientY - rect.top; } else { mouse = { x: -1, y: -1 }; } }

            // --- Utility Functions ---
            function getDistance(obj1, obj2) { const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy); }

            // --- Game Over / Message --- (Unchanged)
            function endGame(win) { /*...*/ gameOver = true; waveInProgress = false; placingTowerType = null; selectedTower = null; const message = win ? `Wave Cleared! Won! Score: ${score}` : `Game Over! Score: ${score}, Wave: ${wave}`; showMessage(message); updateUI(); }
            function showMessage(text) { /*...*/ messageText.textContent = text; messageBox.style.display = 'block'; gamePaused = true; }
            function hideMessage() { /*...*/ messageBox.style.display = 'none'; gamePaused = false; if (!gameOver) requestAnimationFrame(gameLoop); }

            // --- Start the Game ---
            gameLoop();
        };
    </script>
</body>
</html>
