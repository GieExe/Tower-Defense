<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Tower Defense V5</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: flex-start; /* Align top */
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            overflow-x: hidden; /* Prevent horizontal scroll */
            padding-top: 1rem; /* Add some space at the top */
        }
        canvas {
            background-color: #333;
            display: block; /* Important for responsive scaling */
            border: 4px solid #555;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            cursor: pointer;
            /* Responsive Canvas Scaling */
            width: 100%; /* Take full width of container */
            max-width: 600px; /* Max size = original resolution width */
            height: auto; /* Maintain aspect ratio */
            image-rendering: pixelated; /* Keep pixel look when scaled */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 95%; /* Use percentage width */
            max-width: 800px; /* Limit max container width */
            padding: 10px; /* Reduced padding */
        }
        .controls, .stats {
            background-color: #2a2a2a;
            padding: 10px; /* Reduced padding */
            border-radius: 8px;
            border: 2px solid #555;
            margin-bottom: 15px;
            width: 100%; /* Take full width */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .stats {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            justify-content: space-around;
            font-size: clamp(0.7em, 2.5vw, 0.9em); /* Responsive font size */
            text-align: left;
            gap: 10px; /* Add gap between wrapped items */
        }
        /* Control Groups */
        .control-group {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }
        .control-group:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
        .control-group h3 {
             font-size: clamp(0.7em, 2.5vw, 0.9em); /* Responsive font size */
             margin-bottom: 8px;
             color: #aaa;
             text-transform: uppercase;
        }
        /* Buttons General */
        .controls button, .tower-button, .target-button {
            font-family: 'Press Start 2P', cursive;
            color: white; border: none;
            padding: 8px 12px; /* Slightly smaller padding */
            border-radius: 5px; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            margin: 4px; /* Slightly smaller margin */
            border-bottom: 3px solid #555;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            vertical-align: middle;
            font-size: clamp(0.6em, 2vw, 0.8em); /* Responsive font size */
            flex-shrink: 0; /* Prevent buttons from shrinking too much */
        }
        .controls .button-container { /* Flex container for buttons */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .controls button:hover, .tower-button:hover, .target-button:hover { /* ... */ }
        .controls button:active, .tower-button:active, .target-button:active { /* ... */ }

        /* Specific Button Colors (Unchanged) */
        #startWaveBtn { background-color: #28a745; border-bottom-color: #1e7e34; } #startWaveBtn:hover { background-color: #218838; }
        #sellTowerBtn { background-color: #dc3545; border-bottom-color: #a71d2a; } #sellTowerBtn:hover { background-color: #c82333; }
        #upgradeTowerBtn { background-color: #ffc107; border-bottom-color: #ba8b00; color: #333;} #upgradeTowerBtn:hover { background-color: #e0a800; }
        #basicTowerBtn { background-color: #17a2b8; border-bottom-color: #117a8b; } #basicTowerBtn:hover { background-color: #138496; }
        #laserTowerBtn { background-color: #fd7e14; border-bottom-color: #c75e0a; } #laserTowerBtn:hover { background-color: #e66e0c; }
        #slowTowerBtn { background-color: #6495ED; border-bottom-color: #4169E1; } #slowTowerBtn:hover { background-color: #4682B4; }
        #splashTowerBtn { background-color: #800080; border-bottom-color: #4B0082; } #splashTowerBtn:hover { background-color: #6A0DAD; }

        /* Targeting Buttons */
        .target-button { padding: 4px 6px; font-size: clamp(0.5em, 1.8vw, 0.7em); background-color: #444; border-bottom-color: #222; }
        .target-button:hover { background-color: #555; }
        .target-button.active { background-color: #007bff; border-bottom-color: #0056b3; box-shadow: 0 0 5px #0ff; }

        /* Disabled / Selection States (Unchanged) */
        .tower-button.selected { box-shadow: 0 0 10px 3px #0ff; transform: scale(1.05); }
        .tower-button.disabled, #sellTowerBtn.disabled, #startWaveBtn.disabled, #upgradeTowerBtn.disabled, .target-button.disabled { background-color: #6c757d !important; cursor: not-allowed; border-bottom-color: #545b62 !important; box-shadow: none; transform: none; color: #ccc !important; }
        #towerActions, #targetingControls { display: none; }
        #towerActions.visible, #targetingControls.visible { display: block; }

        .message-box { /* Unchanged */ /* ... */ }
        .message-box button { /* Unchanged */ /* ... */ }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="text-2xl md:text-3xl mb-3 md:mb-4 text-cyan-300 text-center">Pixel Tower Defense V5</h1>

        <div class="stats" id="stats">
            <span>Money: <span id="money">120</span></span>
            <span>Score: <span id="score">0</span></span>
            <span>Lives: <span id="lives">10</span></span>
            <span>Wave: <span id="wave">0</span></span>
        </div>

        <div class="controls text-center">
            <div class="control-group">
                <h3>Towers</h3>
                <div class="button-container">
                    <button id="basicTowerBtn" class="tower-button" data-type="basic">Basic</button>
                    <button id="laserTowerBtn" class="tower-button" data-type="laser">Laser</button>
                    <button id="slowTowerBtn" class="tower-button" data-type="slow">Slow</button>
                    <button id="splashTowerBtn" class="tower-button" data-type="splash">Splash</button>
                </div>
            </div>

             <div class="control-group">
                 <h3>Game</h3>
                 <div class="button-container">
                     <button id="startWaveBtn">Start Next Wave</button>
                 </div>
            </div>

             <div id="towerActions" class="control-group">
                 <h3>Tower Actions</h3>
                  <div class="button-container">
                     <button id="upgradeTowerBtn" class="disabled">Upgrade</button>
                     <button id="sellTowerBtn" class="disabled">Sell</button>
                 </div>
             </div>

             <div id="targetingControls" class="control-group">
                 <h3>Target Priority</h3>
                  <div class="button-container">
                     <button class="target-button" data-priority="first">First</button>
                     <button class="target-button" data-priority="last">Last</button>
                     <button class="target-button" data-priority="strongest">Strongest</button>
                     <button class="target-button" data-priority="weakest">Weakest</button>
                 </div>
             </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div id="messageBox" class="message-box">
            <p id="messageText"></p>
            <button id="messageBtn">OK</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // --- Game Configuration ---
            const TILE_SIZE = 40; // Base size for calculations
            const BASE_CANVAS_WIDTH = 600;
            const BASE_CANVAS_HEIGHT = 400;
            const GRID_WIDTH = BASE_CANVAS_WIDTH / TILE_SIZE;
            const GRID_HEIGHT = BASE_CANVAS_HEIGHT / TILE_SIZE;
            const STARTING_MONEY = 120;
            const STARTING_LIVES = 10;
            const WAVE_START_DELAY = 300;
            const ENEMY_SPAWN_INTERVAL = 60;
            const SELL_PERCENTAGE = 0.7;
            const INTEREST_RATE = 0.05; // 5% interest per wave clear

            // --- Enemy Configuration ---
            const ENEMY_TYPES = {
                'normal': { baseHealth: 30, speed: 1, color: '#28a745', sizeFactor: 1.0 },
                'fast':   { baseHealth: 21, speed: 1.8, color: '#ffeb3b', sizeFactor: 0.9 } // ~70% health, 80% faster, yellow
            };
            const ENEMY_HEALTH_INCREMENT = 15; // Applied to baseHealth per wave
            const FAST_ENEMY_CHANCE = 0.20; // 20% chance from wave 3+
            const FAST_ENEMY_START_WAVE = 3;

            // --- Tower Configuration --- (Unchanged from V4)
            const TOWER_TYPES = { /* ... V4 Config ... */
                 'basic': { cost: 50, range: 100, damage: 12, fireRate: 50, color: '#17a2b8', shape: 'rect', maxLevel: 2, upgradeCosts: [75], upgradeStats: [{ damage: 18, range: 110 }] },
                 'laser': { cost: 75, range: 90, damage: 7, fireRate: 25, color: '#fd7e14', shape: 'triangle', maxLevel: 2, upgradeCosts: [100], upgradeStats: [{ damage: 10, fireRate: 20 }] },
                 'slow': { cost: 60, range: 80, damage: 0, fireRate: 30, color: '#6495ED', shape: 'circle', maxLevel: 2, slowFactor: 0.6, slowDuration: 120, upgradeCosts: [70], upgradeStats: [{ range: 95, slowFactor: 0.5 }] },
                 'splash': { cost: 90, range: 90, damage: 8, fireRate: 60, color: '#800080', shape: 'circle', maxLevel: 2, splashRadius: 40, upgradeCosts: [120], upgradeStats: [{ damage: 12, splashRadius: 50 }] }
             };

            // --- Game State ---
            let money = STARTING_MONEY; let score = 0; let lives = STARTING_LIVES; let wave = 0;
            let enemies = []; let towers = []; let projectiles = []; let effects = [];
            let grid = createGrid(); let path = [];
            let placingTowerType = null; let selectedTower = null;
            let mouse = { x: 0, y: 0 }; // Raw mouse position over the element
            let scaledMouse = { x: 0, y: 0 }; // Mouse position scaled to canvas internal resolution
            let waveInProgress = false; let enemiesToSpawn = 0; let spawnTimer = 0;
            let frameCount = 0; let gameOver = false; let gamePaused = false;
            let scaleX = 1, scaleY = 1; // Canvas scaling factors

            // --- UI Elements --- (Unchanged from V4)
            const moneyDisplay = document.getElementById('money'); const scoreDisplay = document.getElementById('score'); const livesDisplay = document.getElementById('lives'); const waveDisplay = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn'); const sellTowerBtn = document.getElementById('sellTowerBtn'); const upgradeTowerBtn = document.getElementById('upgradeTowerBtn');
            const towerButtons = document.querySelectorAll('.tower-button'); const targetButtons = document.querySelectorAll('.target-button');
            const towerActionsDiv = document.getElementById('towerActions'); const targetingControlsDiv = document.getElementById('targetingControls');
            const messageBox = document.getElementById('messageBox'); const messageText = document.getElementById('messageText'); const messageBtn = document.getElementById('messageBtn');

            // --- Path Definition ---
            const pathPoints = [ { x: 0, y: 2 }, { x: 3, y: 2 }, { x: 3, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 4 }, { x: 14, y: 4 } ];
            calculatePixelPath();

            // --- Initialization ---
            updateCanvasScale(); // Initial scale calculation
            updateUI();
            setupEventListeners();

            // --- Game Loop --- (Unchanged from V4)
            function gameLoop() { /* ... V4 Loop ... */
                if (gameOver || gamePaused) { if (!gameOver) requestAnimationFrame(gameLoop); return; }
                frameCount++; ctx.clearRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT); // Use base resolution
                drawGrid(); drawPath(); handleWaves(); handleEnemies(); handleTowers(); handleProjectiles(); handleEffects();
                drawTowers(); drawEnemies(); drawProjectiles(); drawEffects();
                if (placingTowerType) drawTowerPlacementPreview(); // Uses scaledMouse
                requestAnimationFrame(gameLoop);
             }

            // --- Grid and Path --- (Unchanged from V4)
            function createGrid() { /* ... V4 Func ... */ const g=[];for(let y=0;y<GRID_HEIGHT;y++){g[y]=[];for(let x=0;x<GRID_WIDTH;x++)g[y][x]={type:'empty',tower:null}}return g; }
            function calculatePixelPath() { /* ... V4 Func ... */
                 path = []; if (pathPoints.length === 0) return;
                 let totalDistance = 0; const waypoints = [];
                 waypoints.push({ x: pathPoints[0].x * TILE_SIZE - TILE_SIZE, y: pathPoints[0].y * TILE_SIZE + TILE_SIZE / 2, dist: 0 });
                 for (let i = 0; i < pathPoints.length; i++) {
                     const point = pathPoints[i]; const x = point.x * TILE_SIZE + TILE_SIZE / 2; const y = point.y * TILE_SIZE + TILE_SIZE / 2;
                     const prevWaypoint = waypoints[waypoints.length - 1]; const segmentDist = getDistance(prevWaypoint, {x, y}); totalDistance += segmentDist;
                     waypoints.push({ x, y, dist: totalDistance });
                     if (i > 0) { const prevPoint = pathPoints[i - 1]; if (point.x === prevPoint.x) { const sY = Math.min(point.y, prevPoint.y), eY = Math.max(point.y, prevPoint.y); for (let py = sY; py <= eY; py++) if (grid[py]?.[point.x]) grid[py][point.x].type = 'path'; } else { const sX = Math.min(point.x, prevPoint.x), eX = Math.max(point.x, prevPoint.x); for (let px = sX; px <= eX; px++) if (grid[point.y]?.[px]) grid[point.y][px].type = 'path'; } } else { if (grid[point.y]?.[point.x]) grid[point.y][point.x].type = 'path'; }
                 }
                 const lastGridPoint = pathPoints[pathPoints.length - 1]; const endX = (lastGridPoint.x + 1) * TILE_SIZE + TILE_SIZE; const endY = lastGridPoint.y * TILE_SIZE + TILE_SIZE / 2;
                 const lastWaypoint = waypoints[waypoints.length-1]; totalDistance += getDistance(lastWaypoint, {x: endX, y: endY});
                 waypoints.push({ x: endX, y: endY, dist: totalDistance }); path = waypoints;
             }
            function drawGrid() { /* ... V4 Func ... */ ctx.strokeStyle = '#383838'; ctx.lineWidth = 1; for (let y = 0; y < GRID_HEIGHT; y++) for (let x = 0; x < GRID_WIDTH; x++) ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }
            function drawPath() { /* ... V4 Func ... */ ctx.strokeStyle = '#888'; ctx.lineWidth = TILE_SIZE * 0.8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); if (path.length > 0) { ctx.moveTo(path[0].x, path[0].y); for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y); } ctx.stroke(); }

             // --- Enemy Handling ---
            function spawnEnemy() {
                let enemyTypeKey = 'normal';
                // Introduce fast enemies based on wave and chance
                if (wave >= FAST_ENEMY_START_WAVE && Math.random() < FAST_ENEMY_CHANCE) {
                    enemyTypeKey = 'fast';
                }
                const enemyConfig = ENEMY_TYPES[enemyTypeKey];
                const health = (enemyConfig.baseHealth + (wave - 1) * ENEMY_HEALTH_INCREMENT);

                enemies.push({
                    x: path[0].x, y: path[0].y,
                    health: health, maxHealth: health,
                    speed: enemyConfig.speed, pathIndex: 1,
                    size: TILE_SIZE * 0.4 * enemyConfig.sizeFactor, // Use sizeFactor
                    color: enemyConfig.color, // Store color
                    type: enemyTypeKey, // Store type
                    speedMultiplier: 1, slowTimer: 0,
                    distanceTraveled: 0
                });
            }
            function handleEnemies() { /* ... V4 Func, uses enemy.speed ... */
                 for (let i = enemies.length - 1; i >= 0; i--) {
                     const enemy = enemies[i];
                     if (enemy.slowTimer > 0) { enemy.slowTimer--; if (enemy.slowTimer <= 0) enemy.speedMultiplier = 1; }
                     const effectiveSpeed = enemy.speed * enemy.speedMultiplier; // Use base speed from enemy object
                     if (enemy.pathIndex < path.length) {
                         const targetPoint = path[enemy.pathIndex]; const dx = targetPoint.x - enemy.x; const dy = targetPoint.y - enemy.y;
                         const distanceToWaypointSq = dx*dx + dy*dy; // Use squared distance
                         let moveDistance = effectiveSpeed;
                         if (distanceToWaypointSq < moveDistance * moveDistance) { // Compare squares
                             moveDistance = Math.sqrt(distanceToWaypointSq); // Only sqrt when needed
                             enemy.x = targetPoint.x; enemy.y = targetPoint.y; enemy.pathIndex++;
                         } else {
                             const distanceToWaypoint = Math.sqrt(distanceToWaypointSq); // Need sqrt for direction
                             enemy.x += (dx / distanceToWaypoint) * moveDistance; enemy.y += (dy / distanceToWaypoint) * moveDistance;
                         }
                         enemy.distanceTraveled += moveDistance;
                     } else { lives--; updateUI(); enemies.splice(i, 1); if (lives <= 0) endGame(false); continue; }
                     if (enemy.health <= 0) { money += 5 + Math.floor(wave / 5); score += 10; updateUI(); enemies.splice(i, 1); }
                 }
             }
            function drawEnemies() {
                enemies.forEach(enemy => {
                    ctx.fillStyle = enemy.color; // Use enemy's stored color
                    ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = enemy.speedMultiplier < 1 ? '#007bff' : '#1e7e34'; ctx.lineWidth = 2; ctx.stroke();
                    // Health bar (unchanged)
                    const healthBarWidth = enemy.size * 2; const healthBarHeight = 5; const healthPercentage = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#555'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - healthBarHeight - 3, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = '#dc3545'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.size - healthBarHeight - 3, healthBarWidth * healthPercentage, healthBarHeight);
                });
            }

            // --- Tower Handling ---
             function canPlaceTower(gridX, gridY, towerType) { /* ... V4 Func ... */ const c=TOWER_TYPES[towerType];if(!c||!grid[gridY]?.[gridX]||grid[gridY][gridX].type!=='empty'||money<c.cost)return false;return true;}
             function placeTower(gridX, gridY) { /* ... V4 Func ... */
                 if (!placingTowerType) return; const config = TOWER_TYPES[placingTowerType]; if (!config || !canPlaceTower(gridX, gridY, placingTowerType)) return;
                 money -= config.cost; const towerX = gridX * TILE_SIZE + TILE_SIZE / 2; const towerY = gridY * TILE_SIZE + TILE_SIZE / 2;
                 const newTower = { x: towerX, y: towerY, gridX: gridX, gridY: gridY, range: config.range, damage: config.damage, fireRate: config.fireRate, slowFactor: config.slowFactor, slowDuration: config.slowDuration, splashRadius: config.splashRadius, fireCooldown: 0, target: null, type: placingTowerType, level: 1, maxLevel: config.maxLevel, totalCost: config.cost, targetingPriority: 'first' };
                 towers.push(newTower); grid[gridY][gridX].type = 'tower'; grid[gridY][gridX].tower = newTower; deselectTowerPurchase(); updateUI();
              }
            function handleTowers() { /* ... V4 Func ... */ towers.forEach(t => { if (t.fireCooldown > 0) t.fireCooldown--; const rangeSq = t.range * t.range; if (!t.target || t.target.health <= 0 || getDistanceSq(t, t.target) > rangeSq) t.target = findTargetBasedOnPriority(t); if (t.fireCooldown <= 0 && t.target) { if (t.type === 'slow') { applySlowEffect(t); t.fireCooldown = t.fireRate; } else if (t.damage > 0) { fireProjectile(t, t.target); t.fireCooldown = t.fireRate; } } }); }
            function applySlowEffect(tower) { /* ... V4 Func ... */ const rangeSq = tower.range * tower.range; enemies.forEach(e => { if (getDistanceSq(tower, e) <= rangeSq) { e.speedMultiplier = tower.slowFactor; e.slowTimer = tower.slowDuration; } }); }

            // --- Targeting Logic ---
            function findTargetBasedOnPriority(tower) {
                const rangeSq = tower.range * tower.range; // Calculate squared range once
                let potentialTargets = enemies.filter(enemy => getDistanceSq(tower, enemy) <= rangeSq); // Use squared distance
                if (potentialTargets.length === 0) return null;

                switch (tower.targetingPriority) {
                    case 'first': potentialTargets.sort((a, b) => b.distanceTraveled - a.distanceTraveled); break;
                    case 'last': potentialTargets.sort((a, b) => a.distanceTraveled - b.distanceTraveled); break;
                    case 'strongest': potentialTargets.sort((a, b) => b.health - a.health); break;
                    case 'weakest': potentialTargets.sort((a, b) => a.health - b.health); break;
                    default: potentialTargets.sort((a, b) => b.distanceTraveled - a.distanceTraveled); break;
                }
                return potentialTargets[0];
            }

            function drawTowers() { /* ... V4 Func ... */
                 towers.forEach(tower => {
                     const config = TOWER_TYPES[tower.type]; ctx.fillStyle = config.color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.beginPath();
                     const towerSize = TILE_SIZE * 0.3 + (tower.level - 1) * 2;
                     if (config.shape === 'rect') { ctx.rect(tower.x - towerSize, tower.y - towerSize, towerSize * 2, towerSize * 2); }
                     else if (config.shape === 'triangle') { const tS = towerSize * 1.3; ctx.moveTo(tower.x, tower.y - tS * 0.8); ctx.lineTo(tower.x - tS, tower.y + tS * 0.4); ctx.lineTo(tower.x + tS, tower.y + tS * 0.4); ctx.closePath(); }
                     else if (tower.type === 'splash') { ctx.arc(tower.x, tower.y, towerSize, 0, Math.PI * 2); ctx.moveTo(tower.x + towerSize * 0.6, tower.y); ctx.arc(tower.x, tower.y, towerSize * 0.6, 0, Math.PI * 2); }
                     else { ctx.arc(tower.x, tower.y, towerSize, 0, Math.PI * 2); } ctx.fill(); ctx.stroke();
                     if (selectedTower === tower) { const rangeSq = tower.range*tower.range; ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2); ctx.stroke(); } // Range circle unchanged
                     if (tower.level > 1) { ctx.fillStyle = 'yellow'; ctx.font = `${TILE_SIZE * 0.4}px 'Press Start 2P'`; const sS = 4, sSp = 6; const tW = (tower.level - 1) * sSp; const sX = tower.x - tW / 2 + sS / 2; for (let i = 1; i < tower.level; i++) { const starX = sX + (i - 1) * sSp; const starY = tower.y - towerSize - 8; ctx.fillText('*', starX - sS / 2, starY + sS / 2); } }
                 });
             }
            function drawTowerPlacementPreview() { // Uses scaledMouse
                 const gridX = Math.floor(scaledMouse.x / TILE_SIZE); const gridY = Math.floor(scaledMouse.y / TILE_SIZE); // Use scaled mouse coords
                 if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT || !placingTowerType) return;
                 const previewX = gridX * TILE_SIZE + TILE_SIZE / 2; const previewY = gridY * TILE_SIZE + TILE_SIZE / 2;
                 const config = TOWER_TYPES[placingTowerType]; if (!config) return;
                 let canPlace = canPlaceTower(gridX, gridY, placingTowerType);
                 ctx.globalAlpha = 0.5; ctx.fillStyle = canPlace ? config.color : 'red'; ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.beginPath();
                 const previewSize = TILE_SIZE * 0.3;
                 if (config.shape === 'rect') { ctx.rect(previewX - previewSize, previewY - previewSize, previewSize * 2, previewSize * 2); }
                 else if (config.shape === 'triangle') { const tS=previewSize*1.3; ctx.moveTo(previewX,previewY-tS*0.8); ctx.lineTo(previewX-tS,previewY+tS*0.4); ctx.lineTo(previewX+tS,previewY+tS*0.4); ctx.closePath(); }
                 else if (placingTowerType === 'splash') { ctx.arc(previewX, previewY, previewSize, 0, Math.PI * 2); ctx.moveTo(previewX+previewSize*0.6,previewY); ctx.arc(previewX, previewY, previewSize*0.6, 0, Math.PI * 2); }
                 else { ctx.arc(previewX, previewY, previewSize, 0, Math.PI * 2); } ctx.fill(); ctx.stroke();
                 ctx.strokeStyle = canPlace ? 'rgba(255, 255, 255, 0.5)' : 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(previewX, previewY, config.range, 0, Math.PI * 2); ctx.stroke();
                 ctx.globalAlpha = 1.0;
             }
            function upgradeSelectedTower() { /* ... V4 Func ... */ if(!selectedTower||selectedTower.level>=selectedTower.maxLevel)return;const tC=TOWER_TYPES[selectedTower.type];const uI=selectedTower.level-1;if(uI>=tC.upgradeCosts.length){console.error("...");return}const cost=tC.upgradeCosts[uI];if(money>=cost){money-=cost;selectedTower.level++;selectedTower.totalCost+=cost;const nS=tC.upgradeStats[uI];for(const s in nS)if(selectedTower.hasOwnProperty(s))selectedTower[s]=nS[s];console.log(`Upgraded`);updateUI()}else console.log("...");}
            function sellSelectedTower() { /* ... V4 Func ... */ if(!selectedTower)return;const r=Math.floor(selectedTower.totalCost*SELL_PERCENTAGE);money+=r;const i=towers.indexOf(selectedTower);if(i>-1)towers.splice(i,1);const gX=selectedTower.gridX,gY=selectedTower.gridY;if(grid[gY]?.[gX]){grid[gY][gX].type='empty';grid[gY][gX].tower=null}selectedTower=null;updateUI();}

            // --- Projectile Handling ---
            function fireProjectile(tower, target) { /* ... V4 Func ... */ projectiles.push({ x: tower.x, y: tower.y, damage: tower.damage, target: target, speed: 6, size: 4, color: TOWER_TYPES[tower.type]?.color||'yellow', type: tower.type, splashRadius: tower.splashRadius }); }
            function handleProjectiles() { // Uses squared distances
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (!p.target || p.target.health <= 0) { projectiles.splice(i, 1); continue; }
                    const dx = p.target.x - p.x; const dy = p.target.y - p.y;
                    const distanceSq = dx*dx + dy*dy; // Squared distance
                    const speedSq = p.speed * p.speed;

                    if (distanceSq < speedSq) { // Hit target
                        if (p.type === 'splash') {
                            const splashRadiusSq = p.splashRadius * p.splashRadius;
                            enemies.forEach(enemy => {
                                if (getDistanceSq(p.target, enemy) <= splashRadiusSq) { enemy.health -= p.damage; } // Compare squares
                            });
                             addEffect(p.target.x, p.target.y, p.splashRadius, p.color || TOWER_TYPES['splash'].color);
                        } else { p.target.health -= p.damage; }
                        projectiles.splice(i, 1);
                    } else {
                        const distance = Math.sqrt(distanceSq); // Need sqrt for direction
                        p.x += (dx / distance) * p.speed; p.y += (dy / distance) * p.speed;
                    }
                }
            }
            function drawProjectiles() { /* ... V4 Func ... */ projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); }

             // --- Visual Effects Handling --- (Unchanged from V4)
             function addEffect(x, y, radius, color) { /* ... V4 Func ... */ effects.push({ x, y, maxRadius: radius, currentRadius: 0, duration: 20, timer: 20, color: color || 'rgba(255, 255, 0, 0.5)' }); }
             function handleEffects() { /* ... V4 Func ... */ for (let i = effects.length - 1; i >= 0; i--) { const e = effects[i]; e.timer--; e.currentRadius = e.maxRadius * (1 - (e.timer / e.duration)); if (e.timer <= 0) effects.splice(i, 1); } }
             function drawEffects() { /* ... V4 Func ... */ effects.forEach(e => { ctx.beginPath(); ctx.arc(e.x, e.y, e.currentRadius, 0, Math.PI * 2); ctx.strokeStyle = e.color; ctx.lineWidth = 2; ctx.globalAlpha = e.timer / e.duration; ctx.stroke(); ctx.globalAlpha = 1.0; }); }

            // --- Wave Management ---
            function startWave() { /* ... V4 Func ... */ if (waveInProgress || gameOver) return; wave++; enemiesToSpawn = 8 + wave * 3; spawnTimer = ENEMY_SPAWN_INTERVAL; waveInProgress = true; deselectPlacedTower(); updateUI(); }
            function handleWaves() { // Added Interest
                if (!waveInProgress) {
                     if (wave === 0 && frameCount > WAVE_START_DELAY && !gameOver) startWave();
                    return;
                }
                if (enemiesToSpawn > 0 && spawnTimer <= 0) { spawnEnemy(); enemiesToSpawn--; spawnTimer = ENEMY_SPAWN_INTERVAL; }
                spawnTimer--;

                // Check if wave is over
                if (enemiesToSpawn <= 0 && enemies.length === 0) {
                    waveInProgress = false;
                    // End-of-wave bonus + Interest
                    let bonus = 50 + wave * 10;
                    let interest = Math.floor(money * INTEREST_RATE);
                    money += bonus + interest;
                    console.log(`Wave ${wave} cleared! Bonus: ${bonus}$, Interest: ${interest}$`); // Log interest
                    updateUI();
                }
            }

            // --- UI and Interaction ---
            function updateUI() { /* ... V4 Func ... */
                 moneyDisplay.textContent = money; scoreDisplay.textContent = score; livesDisplay.textContent = lives; waveDisplay.textContent = wave;
                 towerButtons.forEach(btn => { const t = btn.dataset.type; const c = TOWER_TYPES[t]; if (!c) return; const cost = c.cost; const d = money < cost || gameOver; btn.disabled = d; btn.classList.toggle('disabled', d); btn.classList.toggle('selected', placingTowerType === t); btn.textContent = `${t.charAt(0).toUpperCase() + t.slice(1)} (${cost}$)`; });
                 startWaveBtn.disabled = waveInProgress || gameOver; startWaveBtn.classList.toggle('disabled', waveInProgress || gameOver);
                 let canSell = false, canUpgrade = false, sellAmount = 0, upgradeCost = 0, currentPriority = null;
                 if (selectedTower && !gameOver) { canSell = true; sellAmount = Math.floor(selectedTower.totalCost * SELL_PERCENTAGE); currentPriority = selectedTower.targetingPriority; if (selectedTower.level < selectedTower.maxLevel) { const tC = TOWER_TYPES[selectedTower.type]; const uI = selectedTower.level - 1; if (uI < tC.upgradeCosts.length) { upgradeCost = tC.upgradeCosts[uI]; if (money >= upgradeCost) canUpgrade = true; } } }
                 towerActionsDiv.classList.toggle('visible', !!selectedTower); sellTowerBtn.disabled = !canSell; sellTowerBtn.textContent = `Sell (${sellAmount}$)`; upgradeTowerBtn.disabled = !canUpgrade; upgradeTowerBtn.textContent = (selectedTower && selectedTower.level >= selectedTower.maxLevel) ? 'Max Lvl' : `Upgrade (${upgradeCost}$)`; // Shortened Max Level text
                 targetingControlsDiv.classList.toggle('visible', !!selectedTower);
                 targetButtons.forEach(btn => { if (selectedTower) { btn.classList.toggle('active', btn.dataset.priority === currentPriority); btn.disabled = gameOver; btn.classList.toggle('disabled', gameOver); } else { btn.classList.remove('active'); btn.disabled = true; btn.classList.add('disabled'); } });
             }

            function setupEventListeners() { /* ... V4 Func ... */
                startWaveBtn.addEventListener('click', startWave); sellTowerBtn.addEventListener('click', sellSelectedTower); upgradeTowerBtn.addEventListener('click', upgradeSelectedTower);
                towerButtons.forEach(btn => { btn.addEventListener('click', () => { const t = btn.dataset.type; const c = TOWER_TYPES[t]; if (c) selectTowerPurchase(t, c.cost); }); });
                targetButtons.forEach(btn => { btn.addEventListener('click', () => { if (selectedTower && !btn.disabled) { selectedTower.targetingPriority = btn.dataset.priority; updateUI(); } }); });
                canvas.addEventListener('click', handleCanvasClick); canvas.addEventListener('mousemove', handleMouseMove); canvas.addEventListener('mouseleave', () => { if (placingTowerType) mouse = { x: -1, y: -1 }; updateScaledMouse(); }); // Update scaled mouse on leave
                document.addEventListener('keydown', (event) => { if (event.key === 'Escape') { deselectTowerPurchase(); deselectPlacedTower(); } });
                document.addEventListener('click', (event) => { if (!canvas.contains(event.target) && !event.target.closest('.controls')) { deselectPlacedTower(); } });
                messageBtn.addEventListener('click', hideMessage);
                window.addEventListener('resize', updateCanvasScale); // Add resize listener
             }

             function selectTowerPurchase(type, cost) { /* ... V4 Func ... */ if (money >= cost && !gameOver) { placingTowerType = type; deselectPlacedTower(); updateUI(); } else { console.log("..."); deselectTowerPurchase(); } }
             function deselectTowerPurchase() { /* ... V4 Func ... */ placingTowerType = null; towerButtons.forEach(btn => btn.classList.remove('selected')); updateUI(); }
             function selectPlacedTower(tower) { /* ... V4 Func ... */ selectedTower = tower; deselectTowerPurchase(); updateUI(); }
             function deselectPlacedTower() { /* ... V4 Func ... */ if (selectedTower) { selectedTower = null; updateUI(); } }

             // --- Mouse Handling with Scaling ---
             function updateCanvasScale() {
                 const rect = canvas.getBoundingClientRect();
                 scaleX = BASE_CANVAS_WIDTH / rect.width;
                 scaleY = BASE_CANVAS_HEIGHT / rect.height;
                 // console.log("Canvas resized, ScaleX:", scaleX, "ScaleY:", scaleY);
             }

             function updateScaledMouse() {
                 const rect = canvas.getBoundingClientRect();
                 // Calculate mouse position relative to the scaled canvas content
                 scaledMouse.x = (mouse.x - rect.left) * scaleX;
                 scaledMouse.y = (mouse.y - rect.top) * scaleY;
             }

             function handleCanvasClick(event) { // Uses scaledMouse
                 mouse.x = event.clientX; // Store raw mouse pos
                 mouse.y = event.clientY;
                 updateScaledMouse(); // Calculate scaled position

                 const gridX = Math.floor(scaledMouse.x / TILE_SIZE);
                 const gridY = Math.floor(scaledMouse.y / TILE_SIZE);

                 // Bounds check for grid coordinates
                  if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT) {
                      console.log("Click outside grid bounds");
                      deselectPlacedTower(); // Deselect if clicking outside
                      return;
                  }

                 if (placingTowerType) { placeTower(gridX, gridY); }
                 else { const clickedTower = grid[gridY]?.[gridX]?.tower; if (clickedTower) { if (selectedTower === clickedTower) deselectPlacedTower(); else selectPlacedTower(clickedTower); } else { deselectPlacedTower(); } }
             }
             function handleMouseMove(event) { // Uses scaledMouse
                 mouse.x = event.clientX; // Store raw mouse pos
                 mouse.y = event.clientY;
                 updateScaledMouse(); // Calculate scaled position
                 // Placement preview drawing uses scaledMouse directly now
             }

            // --- Utility Functions ---
            // Returns distance squared for optimization
            function getDistanceSq(obj1, obj2) { const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return dx*dx + dy*dy; }
            // Original getDistance (only used where needed, e.g., path calculation, enemy movement direction)
            function getDistance(obj1, obj2) { return Math.sqrt(getDistanceSq(obj1, obj2)); }


            // --- Game Over / Message --- (Unchanged)
            function endGame(win) { /* ... V4 Func ... */ gameOver = true; waveInProgress = false; placingTowerType = null; selectedTower = null; const m = win ? `Wave Cleared! Won! Score: ${score}` : `Game Over! Score: ${score}, Wave: ${wave}`; showMessage(m); updateUI(); }
            function showMessage(text) { /* ... V4 Func ... */ messageText.textContent = text; messageBox.style.display = 'block'; gamePaused = true; }
            function hideMessage() { /* ... V4 Func ... */ messageBox.style.display = 'none'; gamePaused = false; if (!gameOver) requestAnimationFrame(gameLoop); }

            // --- Start the Game ---
            gameLoop();
        };
    </script>
</body>
</html>
